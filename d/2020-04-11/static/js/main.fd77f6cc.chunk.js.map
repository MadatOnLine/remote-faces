{"version":3,"sources":["../../node_modules/peerjs/dist sync","utils/hash.ts","utils/sleep.ts","network/peerUtils.ts","network/room.ts","capture/webcam.ts","components/SingleRoom.tsx","hooks/useFaceImages.ts","components/SingleRoomEntrance.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","sha256","text","a","encoder","TextEncoder","data","encode","crypto","subtle","digest","buf","arr","Array","from","Uint8Array","hex","map","b","toString","padStart","join","sleep","ms","Promise","setTimeout","isConnectedConn","conn","ignoreConnecting","peerConn","peerConnection","connState","connectionState","signalingState","getLivePeers","myPeer","Object","connections","filter","peer","some","guessSeed","Number","split","createMyPeer","index","roomId","updateNetworkStatus","type","peerId","Math","floor","random","console","log","Peer","on","err","destroy","then","error","createRoom","receiveData","lastBroadcastData","showConnectedStatus","closedPeerId","peerIds","connectPeer","conns","c","connect","serialization","initConnection","send","peers","payload","isArray","forEach","startsWith","handlePayload","reInitMyPeer","initMyPeer","i","disconnectedId","waitSec","checkSeeds","broadcastData","key","open","dispose","captureImage","stream","track","ImageCapture","imageCapture","takePhoto","blob","createImageBitmap","srcImg","grabFrame","srcW","width","srcH","height","video","document","getElementById","style","display","srcObject","videoWidth","videoHeight","navigator","mediaDevices","getUserMedia","getVideoTracks","canvas","ctx","getContext","dstW","dstH","ratio","max","min","x","y","drawImage","stop","toDataURL","SingleRoom","userId","nickname","messageRef","useRef","getFaceInfo","useState","myImage","setMyImage","roomImages","setRoomImages","networkStatus","useEffect","_peerId","image","info","message","roomImage","received","Date","now","obsoleted","prev","found","next","item","checkObsoletedImage","twoMinAgo","changed","loop","timer","setInterval","clearTimeout","useFaceImages","useCallback","current","className","JSON","stringify","src","alt","onChange","target","value","opacity","SingleRoomEntrance","setRoomId","setUserId","roomName","setRoomName","setNickname","onSubmit","preventDefault","disabled","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","serviceWorker","ready","registration","unregister","catch"],"mappings":"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","file":"static/js/main.fd77f6cc.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 18;","export const sha256 = async (text: string) => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n  const buf = await crypto.subtle.digest(\"SHA-256\", data);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const rand4 = () => 1000 + Math.floor(Math.random() * 9000);\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import Peer from \"peerjs\";\n\nexport type Conn = Peer[\"connections\"][0];\n\nexport const isConnectedConn = (conn: Conn, ignoreConnecting = false) => {\n  if (!conn) return false;\n  const peerConn = conn.peerConnection;\n  if (!peerConn) return false;\n  const connState = peerConn.connectionState;\n  if (connState === \"connected\") return true;\n  if (!ignoreConnecting) {\n    if (connState === \"connecting\" || connState === \"new\") {\n      return true;\n    }\n  }\n  // for safari\n  if (!connState && peerConn.signalingState === \"stable\") return true;\n  return false;\n};\n\nexport const getLivePeers = (myPeer: Peer) => {\n  const peers = Object.keys(myPeer.connections);\n  const livePeers = peers.filter((peer) =>\n    myPeer.connections[peer].some((conn: Conn) => isConnectedConn(conn, true))\n  );\n  return livePeers;\n};\n","import Peer from \"peerjs\";\n\nimport { rand4 } from \"../utils/hash\";\nimport { sleep } from \"../utils/sleep\";\nimport { Conn, isConnectedConn, getLivePeers } from \"./peerUtils\";\n\nconst SEED_PEERS = 5; // config\nconst guessSeed = (id: string) => Number(id.split(\"_\")[1]) < SEED_PEERS;\n\nexport type NetworkStatus =\n  | { type: \"CONNECTING_SEED_PEERS\" }\n  | { type: \"NEW_CONNECTION\"; peerId: number }\n  | { type: \"INITIALIZING_PEER\"; index: number }\n  | { type: \"NETWORK_ERROR\" }\n  | { type: \"UNKNOWN_ERROR\" }\n  | { type: \"CONNECTED_PEERS\"; peerIds: number[] };\n\ntype UpdateNetworkStatus = (status: NetworkStatus) => void;\n\ntype ReceiveData = (peerId: number, data: unknown) => void;\n\nconst createMyPeer = (\n  index: number,\n  roomId: string,\n  updateNetworkStatus: UpdateNetworkStatus\n): Promise<Peer> => {\n  updateNetworkStatus({ type: \"INITIALIZING_PEER\", index });\n  const isSeed = index < SEED_PEERS;\n  const peerId = isSeed ? index : rand4();\n  const id = `${roomId}_${peerId}`;\n  console.log(\"createMyPeer\", index, id);\n  const peer = new Peer(id);\n  return new Promise((resolve) => {\n    peer.on(\"open\", () => {\n      resolve(peer);\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        peer.destroy();\n        createMyPeer(index + 1, roomId, updateNetworkStatus).then(resolve);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"network\") {\n        console.log(\"createMyPeer network error\", err);\n        updateNetworkStatus({ type: \"NETWORK_ERROR\" });\n      } else {\n        console.error(\"createMyPeer\", err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\" });\n      }\n    });\n  });\n};\n\nexport const createRoom = (\n  roomId: string,\n  updateNetworkStatus: UpdateNetworkStatus,\n  receiveData: ReceiveData\n) => {\n  let myPeer: Peer | null = null;\n  let lastBroadcastData: unknown | null = null;\n\n  const showConnectedStatus = (closedPeerId?: number) => {\n    if (!myPeer) return;\n    const peerIds = getLivePeers(myPeer)\n      .map((id) => Number(id.split(\"_\")[1]))\n      .filter((peerId) => peerId !== closedPeerId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIds });\n  };\n\n  const connectPeer = (id: string) => {\n    if (!myPeer) return;\n    if (myPeer.id === id) return;\n    const conns = myPeer.connections[id];\n    const hasEffectiveConn = conns && conns.some(isConnectedConn);\n    if (hasEffectiveConn) return;\n    console.log(\n      \"connectPeer\",\n      id,\n      conns &&\n        conns.map(\n          (c: Conn) => c.peerConnection && c.peerConnection.connectionState\n        )\n    );\n    const conn = myPeer.connect(id, { serialization: \"json\" });\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown) => {\n    lastBroadcastData = data;\n    if (myPeer) {\n      Object.keys(myPeer.connections).forEach((key) => {\n        if (!myPeer) return;\n        const peers = getLivePeers(myPeer);\n        myPeer.connections[key].forEach((conn: Conn) => {\n          if (conn.open) {\n            try {\n              conn.send({ data, peers });\n            } catch (e) {\n              console.error(\"broadcastData\", e);\n            }\n          }\n        });\n      });\n    }\n  };\n\n  const handlePayload = (conn: Conn, payload: unknown) => {\n    try {\n      const peerId = Number(conn.peer.split(\"_\")[1]);\n      if (payload && typeof payload === \"object\") {\n        receiveData(peerId, (payload as { data: unknown }).data);\n        if (Array.isArray((payload as { peers: unknown }).peers)) {\n          (payload as { peers: unknown[] }).peers.forEach((peer) => {\n            if (typeof peer === \"string\" && peer.startsWith(`${roomId}_`)) {\n              connectPeer(peer);\n            }\n          });\n        }\n      }\n    } catch (e) {\n      console.error(\"handlePayload\", e);\n    }\n  };\n\n  const initConnection = (conn: Conn) => {\n    conn.on(\"open\", () => {\n      showConnectedStatus();\n      if (myPeer && lastBroadcastData) {\n        conn.send({\n          data: lastBroadcastData,\n          peers: getLivePeers(myPeer),\n        });\n      }\n    });\n    conn.on(\"data\", (payload: unknown) => handlePayload(conn, payload));\n    conn.on(\"close\", async () => {\n      console.log(\"dataConnection closed\", conn);\n      showConnectedStatus(Number(conn.peer.split(\"_\")[1]));\n      if (guessSeed(conn.peer)) reInitMyPeer(conn.peer);\n    });\n    conn.on(\"error\", async (err: Error) => {\n      console.error(\"dataConnection error\", conn, err);\n      showConnectedStatus(Number(conn.peer.split(\"_\")[1]));\n      if (guessSeed(conn.peer)) reInitMyPeer(conn.peer);\n    });\n  };\n\n  const initMyPeer = async () => {\n    if (myPeer) return;\n    myPeer = await createMyPeer(0, roomId, updateNetworkStatus);\n    myPeer.on(\"connection\", (conn) => {\n      console.log(\"new connection received\", conn);\n      const peerId = Number(conn.peer.split(\"_\")[1]);\n      updateNetworkStatus({ type: \"NEW_CONNECTION\", peerId });\n      initConnection(conn);\n    });\n    updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n    for (let i = 0; i < SEED_PEERS; i += 1) {\n      const id = `${roomId}_${i}`;\n      connectPeer(id);\n    }\n  };\n  initMyPeer();\n\n  const reInitMyPeer = async (disconnectedId: string) => {\n    if (!myPeer) return;\n    if (guessSeed(myPeer.id)) return;\n    const waitSec = 30 + Math.floor(Math.random() * 60);\n    console.log(\n      \"Disconnected seed peer: \" +\n        disconnectedId.split(\"_\")[1] +\n        \", reinit in \" +\n        waitSec +\n        \"sec...\"\n    );\n    await sleep(waitSec * 1000);\n    if (!myPeer) return;\n    if (guessSeed(myPeer.id)) return;\n    let checkSeeds = true;\n    for (let i = 0; i < SEED_PEERS; i += 1) {\n      const id = `${roomId}_${i}`;\n      const conns = myPeer.connections[id] || [];\n      if (!conns.some(isConnectedConn)) {\n        checkSeeds = false;\n      }\n    }\n    if (checkSeeds) {\n      showConnectedStatus();\n      return;\n    }\n    myPeer.destroy();\n    myPeer = null;\n    initMyPeer();\n  };\n\n  const dispose = () => {\n    if (myPeer) {\n      myPeer.destroy();\n      // do not set null\n    }\n  };\n\n  return {\n    broadcastData,\n    dispose,\n  };\n};\n","import { sleep } from \"../utils/sleep\";\n\nconst captureImage = async (stream: MediaStream, track: MediaStreamTrack) => {\n  if (typeof ImageCapture !== \"undefined\") {\n    const imageCapture = new ImageCapture(track);\n    await sleep(2000);\n    let srcImg;\n    try {\n      const blob = await imageCapture.takePhoto();\n      srcImg = await createImageBitmap(blob);\n    } catch (e) {\n      srcImg = await imageCapture.grabFrame();\n    }\n    const srcW = srcImg.width;\n    const srcH = srcImg.height;\n    return { srcImg, srcW, srcH };\n  }\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  video.srcObject = stream;\n  await sleep(2000);\n  const srcImg = video;\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  return { srcImg, srcW, srcH };\n};\n\nexport const takePhoto = async () => {\n  const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n  const track = stream.getVideoTracks()[0];\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = (canvas.width = 72);\n  const dstH = (canvas.height = 72);\n  const { srcImg, srcW, srcH } = await captureImage(stream, track);\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  ctx.drawImage(srcImg, x, y, width, height, 0, 0, dstW, dstH);\n  track.stop();\n  return canvas.toDataURL(\"image/png\");\n};\n","import React, { useCallback, useRef } from \"react\";\n\nimport { useFaceImages } from \"../hooks/useFaceImages\";\n\nconst BLANK_IMAGE =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQI12NgYAAAAAMAASDVlMcAAAAASUVORK5CYII=\";\n\ntype Props = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n};\n\nconst SingleRoom: React.FC<Props> = ({ roomId, userId, nickname }) => {\n  const messageRef = useRef(\"\");\n\n  const getFaceInfo = useCallback(\n    () => ({\n      nickname,\n      message: messageRef.current,\n    }),\n    [nickname]\n  );\n  const { myImage, roomImages, networkStatus } = useFaceImages(\n    roomId,\n    userId,\n    getFaceInfo\n  );\n\n  return (\n    <>\n      <div className=\"status\">{JSON.stringify(networkStatus)}</div>\n      <div>\n        <div className=\"card\">\n          <img src={myImage || BLANK_IMAGE} className=\"photo\" alt=\"myself\" />\n          <div className=\"name\">{nickname}</div>\n          <div className=\"mesg\">\n            <form>\n              <input\n                onChange={(e) => {\n                  messageRef.current = e.target.value;\n                }}\n              />\n            </form>\n          </div>\n        </div>\n        {roomImages.map((item) => (\n          <div\n            key={item.userId}\n            className=\"card\"\n            style={{ opacity: item.obsoleted ? 0.2 : 1 }}\n          >\n            <img src={item.image} className=\"photo\" alt=\"friend\" />\n            <div className=\"name\">{item.info.nickname}</div>\n            <div className=\"mesg\">{item.info.message}</div>\n          </div>\n        ))}\n      </div>\n    </>\n  );\n};\n\nexport default SingleRoom;\n","import { useEffect, useState } from \"react\";\n\nimport { createRoom, NetworkStatus } from \"../network/room\";\nimport { takePhoto } from \"../capture/webcam\";\n\ntype ImageUrl = string;\ntype FaceInfo = {\n  nickname: string;\n  message: string;\n};\ntype RoomImage = {\n  userId: string;\n  image: ImageUrl;\n  info: FaceInfo;\n  received: number; // in milliseconds\n  obsoleted: boolean;\n};\n\nconst isFaceInfo = (x: unknown): x is FaceInfo =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { message: unknown }).message === \"string\";\n\nexport const useFaceImages = (\n  roomId: string,\n  userId: string,\n  getFaceInfo: () => FaceInfo\n) => {\n  const [myImage, setMyImage] = useState<ImageUrl>();\n  const [roomImages, setRoomImages] = useState<RoomImage[]>([]);\n  const [networkStatus, updateNetworkStatus] = useState<NetworkStatus>();\n\n  useEffect(() => {\n    const receiveData = (_peerId: number, data: unknown) => {\n      if (\n        data &&\n        typeof data === \"object\" &&\n        typeof (data as { userId: unknown }).userId === \"string\" &&\n        typeof (data as { image: unknown }).image === \"string\" &&\n        isFaceInfo((data as { info: unknown }).info)\n      ) {\n        const roomImage: RoomImage = {\n          userId: (data as { userId: string }).userId,\n          image: (data as { image: ImageUrl }).image,\n          info: (data as { info: FaceInfo }).info,\n          received: Date.now(),\n          obsoleted: false,\n        };\n        setRoomImages((prev) => {\n          let found = false;\n          const next = prev.map((item) => {\n            if (item.userId === roomImage.userId) {\n              found = true;\n              return roomImage;\n            }\n            return item;\n          });\n          return found ? next : [...prev, roomImage];\n        });\n      }\n    };\n    const { broadcastData, dispose } = createRoom(\n      roomId,\n      updateNetworkStatus,\n      receiveData\n    );\n    const checkObsoletedImage = () => {\n      const twoMinAgo = Date.now() - 2 * 60 * 1000;\n      setRoomImages((prev) => {\n        let changed = false;\n        const next = prev.map((item) => {\n          if (item.received < twoMinAgo && !item.obsoleted) {\n            changed = true;\n            return { ...item, obsoleted: true };\n          }\n          return item;\n        });\n        return changed ? next : prev;\n      });\n    };\n    const loop = async () => {\n      try {\n        checkObsoletedImage();\n        const image = await takePhoto();\n        setMyImage(image);\n        const data = {\n          userId,\n          image,\n          info: getFaceInfo(),\n        };\n        broadcastData(data);\n      } catch (e) {\n        console.error(e);\n        // TODO ErrorBoundary\n      }\n    };\n    loop();\n    const timer = setInterval(loop, 2 * 60 * 1000);\n    return () => {\n      dispose();\n      clearTimeout(timer);\n    };\n  }, [roomId, userId, getFaceInfo]);\n\n  return {\n    myImage,\n    roomImages,\n    networkStatus,\n  };\n};\n","import React, { useState } from \"react\";\n\nimport { sha256 } from \"../utils/hash\";\nimport SingleRoom from \"./SingleRoom\";\n\nconst SingleRoomEntrance: React.FC = () => {\n  const [roomId, setRoomId] = useState<string>();\n  const [userId, setUserId] = useState<string>();\n  const [roomName, setRoomName] = useState(\"\");\n  const [nickname, setNickname] = useState(\"\");\n\n  const onSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    setRoomId(await sha256(roomName));\n    setUserId(await sha256(`${roomName}_${Date.now()}`));\n  };\n\n  if (roomId && userId && nickname) {\n    return <SingleRoom roomId={roomId} userId={userId} nickname={nickname} />;\n  }\n\n  return (\n    <form className=\"init\" onSubmit={onSubmit}>\n      <table>\n        <tbody>\n          <tr>\n            <td>Room Name:</td>\n            <td>\n              <input\n                value={roomName}\n                onChange={(e) => setRoomName(e.target.value)}\n              />\n            </td>\n          </tr>\n          <tr>\n            <td>Your Name:</td>\n            <td>\n              <input\n                value={nickname}\n                onChange={(e) => setNickname(e.target.value)}\n              />\n            </td>\n          </tr>\n          <tr>\n            <td></td>\n            <td>\n              <input\n                type=\"submit\"\n                value=\"Enter\"\n                disabled={!roomName || !nickname}\n              />\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </form>\n  );\n};\n\nexport default SingleRoomEntrance;\n","import React from \"react\";\n\nimport SingleRoomEntrance from \"./SingleRoomEntrance\";\nimport \"./App.css\";\n\nconst App: React.FC = () => (\n  <div className=\"SingleRoomEntrance\">\n    <SingleRoomEntrance />\n  </div>\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}