{"version":3,"sources":["../../node_modules/peerjs/dist sync","components/ErrorFallback.tsx","utils/crypto.ts","utils/url.ts","network/peerUtils.ts","network/room.ts","hooks/useRoom.ts","media/devices.ts","utils/sleep.ts","media/capture.ts","media/video.ts","media/audio.ts","hooks/useFaceVideos.ts","components/FaceImages.tsx","hooks/useFaceImages.ts","hooks/useMomentaryChat.ts","components/MomentaryChat.tsx","media/screen.ts","hooks/useScreenShare.ts","components/ScreenShare.tsx","hooks/useNicknameMap.ts","components/SingleRoom.tsx","utils/storage.ts","hooks/useAvailableDevices.ts","utils/emoji.ts","components/SingleRoomEntrance.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","ErrorFallback","useState","waitSec","setWaitSec","useEffect","setTimeout","window","location","reload","secureRandomId","arrbuf","crypto","getRandomValues","Uint8Array","Array","from","map","b","toString","padStart","join","rand4","Uint16Array","extractRoomIdFromLink","link","hash","URL","slice","URLSearchParams","get","getServerConfigFromUrl","server","url","secure","protocol","defaultPort","host","split","port","Number","path","pathname","generatePeerId","roomId","peerIndex","getPeerIndexFromPeerId","peerId","getPeerIndexFromConn","conn","peer","guessSeed","createRoom","userId","updateNetworkStatus","receiveData","receiveTrack","disposed","myPeer","lastBroadcastData","connMap","Map","addConn","value","close","set","mediaTypes","markConnected","connected","isConnected","setUserId","getUserId","setMediaTypes","getMediaTypes","hasConn","has","delConn","delete","getConnectedPeerIds","filter","k","forEachConnectedConns","callback","values","forEach","forEachConnsAcceptingMedia","mediaType","includes","clearAll","size","console","log","clear","createConnectionMap","localStream","showConnectedStatus","peerIndexList","type","connectPeer","connect","serialization","initConnection","broadcastData","data","replaceLastData","peers","send","error","sendSDP","sdp","SDP","handleSDP","a","offer","peerConnection","setRemoteDescription","createAnswer","answer","setLocalDescription","warn","handlePayload","payload","payloadUserId","handleUserId","payloadMediaTypes","isArray","every","x","syncTracks","handleMediaTypes","startsWith","isValidPeerId","connUserId","info","on","addEventListener","createOffer","event","track","length","reInitMyPeer","disconnected","Math","floor","random","initMyPeer","index","isSeed","Peer","debug","i","seedId","err","destroy","destroyed","reconnect","force","existsAllSeeds","oldPeer","trackMediaTypeMap","WeakMap","senders","getSenders","mTypes","getTracks","mType","sender","addTrack","removeTrack","acceptMediaTypes","MediaStream","name","find","s","dispose","roomEntryMap","register","networkStatusListener","dataListener","trackListener","roomEntryKey","entry","networkStatusListeners","Set","dataListeners","trackListeners","room","status","listener","count","add","mediaTypeSet","prevSize","definedEntry","unregister","useRoomNetworkStatus","onNetworkStatus","networkStatus","ns","useBroadcastData","broadcastDataRef","useRef","useCallback","current","registered","useRoomData","onRoomData","undefined","useRoomMedia","onTrack","functions","setFunctions","result","getVideoDeviceInfoList","navigator","mediaDevices","enumerateDevices","devices","list","kind","label","deviceId","getAudioDeviceInfoList","sleep","ms","Promise","captureImage","stream","ImageCapture","imageCapture","takePhoto","blob","createImageBitmap","srcImg","grabFrame","srcW","width","srcH","height","video","document","getElementById","style","display","savedSrcObject","srcObject","revert","videoWidth","videoHeight","constraints","getUserMedia","getVideoTracks","canvas","ctx","getContext","dstW","dstH","ratio","max","min","y","drawImage","stop","toDataURL","getVideoStream","timer","setInterval","canvasStream","captureStream","clearInterval","checkVideTrackFaceSize","createElement","videoTrackFaceSizeMap","isVideoTrackFaceSize","promise","getAudioStream","audio","getAudioTracks","applyConstraints","echoCancellation","echoCancellationType","ideal","noiseSuppression","addTrackWithNewStream","prevVideoTrack","prevAudioTrack","newStream","removeTrackWithNewStream","FaceImage","React","memo","image","nickname","statusMesg","obsoleted","liveMode","speakerOn","className","opacity","ref","videoEle","autoPlay","muted","src","alt","title","micOn","videoDeviceId","audioDeviceId","myImage","setMyImage","roomImages","setRoomImages","fatalError","setFatalError","message","isFaceInfo","roomImage","received","Date","now","prev","item","changed","next","checkObsoletedImage","twoMinAgo","tenMinAgo","loop","clearTimeout","useFaceImages","videoEnabled","audioEnabled","faceStream","setFaceStream","faceStreamMap","setFaceStreamMap","cleanupFns","fn","onended","push","removeEventListener","addVideoTrack","removeVideoTrack","addAudioTrack","removeAudioTrack","videoStream","disposeVideo","videoTrack","audioStream","disposeAudio","audioTrack","enabled","useFaceVideos","key","compareReply","countDiff","reactions","ReactionButton","text","onClick","aria-label","MomentaryChatContent","chatList","replyChat","reply","replyTo","replies","chatSeqRef","receivedSeqMap","setChatList","addChatItem","chatData","chatSeq","chatInReplyTo","chatText","replyMap","entries","sort","chatItem","sendChat","inReplyTo","useMomentaryChat","setText","onSubmit","preventDefault","onChange","target","placeholder","disabled","getScreenStream","getDisplayMedia","isScreenTrack","isFaceSize","Screen","videoRef","setEnabled","screenStream","setScreenStream","screenStreamMap","setScreenStreamMap","onmute","timeout","onunmute","contentHint","useScreenShare","nicknameMap","setNicknameMap","useNicknameMap","Object","screenUserId","initialNickname","localStorage","getItem","getStringItem","TextField","initialText","onUpdate","buttonLabel","clearOnUpdate","SingleRoom","setNickname","setStatusMesg","emoji","setEmoji","openEmojiPicker","setOpenEmojiPicker","searchParams","setRoomIdToUrl","videoDevices","setDevices","deviceInfoList","useVideoDevices","audioDevices","useAudioDevices","setVideoDeviceId","setAudioDeviceId","setLiveMode","setMicOn","setSpeakerOn","screenShareMode","setScreenShareMode","configOpen","setConfigOpen","appLink","href","replace","JSON","stringify","readOnly","setItem","setStringItem","onSelect","emojiData","isEmojiDataType","videoDevice","audioDevice","checked","native","roomIdFromUrl","getRoomIdFromUrl","SingleRoomEntrance","setRoomId","linkText","setLinkText","ErrorBoundary","state","hasError","children","this","props","Component","App","Boolean","hostname","match","ReactDOM","render","StrictMode","serviceWorker","ready","then","registration","catch"],"mappings":"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","file":"static/js/main.508cf48e.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 37;","import React, { useEffect, useState } from \"react\";\n\nconst ErrorFallback: React.FC = () => {\n  const [waitSec, setWaitSec] = useState(30);\n\n  useEffect(() => {\n    if (waitSec > 0) {\n      setTimeout(() => {\n        setWaitSec(waitSec - 1);\n      }, 1000);\n    } else {\n      window.location.reload();\n    }\n  });\n\n  return (\n    <div>\n      <h1>Unrecoverable error occurred.</h1>\n      <p>Will auto reload in {waitSec} sec.</p>\n    </div>\n  );\n};\n\nexport default ErrorFallback;\n","export const sha256 = async (text: string) => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n  const buf = await window.crypto.subtle.digest(\"SHA-256\", data);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const secureRandomId = () => {\n  const arrbuf = window.crypto.getRandomValues(new Uint8Array(32));\n  const arr = Array.from(arrbuf);\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const rand4 = () => {\n  const rand = window.crypto.getRandomValues(new Uint16Array(1))[0];\n  return 1000 + (rand % 9000);\n};\n","export const extractRoomIdFromLink = (link: string) => {\n  try {\n    const hash = new URL(link).hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    return searchParams.get(\"roomId\");\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getRoomIdFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.get(\"roomId\");\n};\n\nexport const setRoomIdToUrl = (roomId: string) => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  searchParams.set(\"roomId\", roomId);\n  window.location.hash = searchParams.toString();\n};\n\nexport const getServerConfigFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  const server = searchParams.get(\"server\");\n  try {\n    const url = new URL(server || \"\");\n    const secure = url.protocol === \"https:\";\n    const defaultPort = secure ? 443 : 80;\n    return {\n      host: url.host.split(\":\")[0],\n      port: url.port ? Number(url.port) : defaultPort,\n      path: url.pathname,\n      secure,\n    };\n  } catch (e) {\n    // ignore\n  }\n  return null;\n};\n","import Peer from \"peerjs\";\n\nexport const isValidPeerId = (\n  roomId: string,\n  peerId: unknown\n): peerId is string =>\n  typeof peerId === \"string\" && peerId.startsWith(`${roomId.slice(0, 32)} `);\n\nexport const generatePeerId = (roomId: string, peerIndex: number) =>\n  `${roomId.slice(0, 32)} ${peerIndex}`;\n\nexport const getPeerIndexFromPeerId = (peerId: string) =>\n  Number(peerId.split(\" \")[1]);\n\nexport const getPeerIndexFromConn = (conn: Peer.DataConnection) =>\n  getPeerIndexFromPeerId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    connected?: boolean;\n    userId?: string;\n    mediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const addConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.conn.close();\n    }\n    map.set(conn.peer, { conn, mediaTypes: [] });\n  };\n\n  const markConnected = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.connected = true;\n    }\n  };\n\n  const isConnected = (peerId: string) => {\n    const value = map.get(peerId);\n    return (value && value.connected) || false;\n  };\n\n  const setUserId = (conn: Peer.DataConnection, userId: string) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.userId = userId;\n    }\n  };\n\n  const getUserId = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return value && value.userId;\n  };\n\n  const setMediaTypes = (conn: Peer.DataConnection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.mediaTypes = mediaTypes;\n    }\n  };\n\n  const getMediaTypes = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return (value && value.mediaTypes) || [];\n  };\n\n  const hasConn = (peerId: string) => map.has(peerId);\n\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    }\n  };\n\n  const getConnectedPeerIds = () =>\n    Array.from(map.keys()).filter((k) => map.get(k)?.connected);\n\n  const forEachConnectedConns = (\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (\n        value.connected &&\n        value.mediaTypes &&\n        value.mediaTypes.includes(mediaType)\n      ) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const clearAll = () => {\n    if (map.size) {\n      console.log(\"connectionMap garbage:\", map);\n    }\n    map.clear();\n  };\n\n  return {\n    addConn,\n    markConnected,\n    isConnected,\n    setUserId,\n    getUserId,\n    setMediaTypes,\n    getMediaTypes,\n    hasConn,\n    delConn,\n    getConnectedPeerIds,\n    forEachConnectedConns,\n    forEachConnsAcceptingMedia,\n    clearAll,\n  };\n};\n","import Peer from \"peerjs\";\n\nimport { rand4 } from \"../utils/crypto\";\nimport { getServerConfigFromUrl } from \"../utils/url\";\nimport {\n  isValidPeerId,\n  generatePeerId,\n  getPeerIndexFromPeerId,\n  getPeerIndexFromConn,\n  createConnectionMap,\n} from \"./peerUtils\";\n\nconst MIN_SEED_PEER_INDEX = 10; // config\nconst MAX_SEED_PEER_INDEX = 14; // config\nconst guessSeed = (id: string) => {\n  const peerIndex = getPeerIndexFromPeerId(id);\n  return MIN_SEED_PEER_INDEX <= peerIndex && peerIndex <= MAX_SEED_PEER_INDEX;\n};\n\nexport type NetworkStatus =\n  | { type: \"CONNECTING_SEED_PEERS\" }\n  | { type: \"NEW_CONNECTION\"; peerIndex: number }\n  | { type: \"CONNECTION_CLOSED\"; peerIndex: number }\n  | { type: \"INITIALIZING_PEER\"; peerIndex: number }\n  | { type: \"RECONNECTING\" }\n  | { type: \"UNKNOWN_ERROR\" }\n  | { type: \"CONNECTED_PEERS\"; peerIndexList: number[] };\n\ntype UpdateNetworkStatus = (status: NetworkStatus) => void;\n\nexport type PeerInfo = {\n  userId: string;\n  peerIndex: number;\n  mediaTypes: string[];\n};\ntype ReceiveData = (data: unknown, info: PeerInfo) => void;\ntype ReceiveTrack = (track: MediaStreamTrack, info: PeerInfo) => void;\n\nexport const createRoom = (\n  roomId: string,\n  userId: string,\n  updateNetworkStatus: UpdateNetworkStatus,\n  receiveData: ReceiveData,\n  receiveTrack: ReceiveTrack\n) => {\n  let disposed = false;\n  let myPeer: Peer | null = null;\n  let lastBroadcastData: unknown | null = null;\n  const connMap = createConnectionMap();\n  let mediaTypes: string[] = [];\n  let localStream: MediaStream | null = null;\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap\n      .getConnectedPeerIds()\n      .map(getPeerIndexFromPeerId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed) return;\n    if (!myPeer || myPeer.id === id) return;\n    if (connMap.hasConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id, { serialization: \"json\" });\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown, replaceLastData?: boolean) => {\n    if (disposed) return;\n    if (replaceLastData) {\n      lastBroadcastData = data;\n    }\n    const peers = connMap.getConnectedPeerIds();\n    connMap.forEachConnectedConns((conn) => {\n      try {\n        conn.send({ roomId, userId, data, peers, mediaTypes });\n      } catch (e) {\n        console.error(\"broadcastData\", e);\n      }\n    });\n  };\n\n  const sendSDP = (conn: Peer.DataConnection, sdp: unknown) => {\n    conn.send({ roomId, SDP: sdp });\n  };\n\n  const handleSDP = async (conn: Peer.DataConnection, sdp: unknown) => {\n    if (!sdp || typeof sdp !== \"object\") return;\n    if (typeof (sdp as { offer: unknown }).offer === \"object\") {\n      const { offer } = sdp as { offer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(offer as any);\n        const answer = await conn.peerConnection.createAnswer();\n        await conn.peerConnection.setLocalDescription(answer);\n        sendSDP(conn, { answer });\n      } catch (e) {\n        console.log(\"handleSDP offer failed\", e);\n      }\n    } else if (typeof (sdp as { answer: unknown }).answer === \"object\") {\n      const { answer } = sdp as { answer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(answer as any);\n      } catch (e) {\n        console.log(\"handleSDP answer failed\", e);\n      }\n    } else {\n      console.warn(\"unkonwn SDP\", sdp);\n    }\n  };\n\n  const handleUserId = (conn: Peer.DataConnection, payloadUserId: unknown) => {\n    if (typeof payloadUserId === \"string\") {\n      connMap.setUserId(conn, payloadUserId as string);\n    }\n  };\n\n  const handleMediaTypes = (\n    conn: Peer.DataConnection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setMediaTypes(conn, payloadMediaTypes as string[]);\n      // We need to delay because negotiation is in progress\n      // FIXME there should be better way than timeout\n      setTimeout(() => {\n        syncTracks(conn);\n      }, 3000);\n    }\n  };\n\n  const handlePayload = (conn: Peer.DataConnection, payload: unknown) => {\n    if (disposed) return;\n    if (!payload && typeof payload !== \"object\") return;\n    if ((payload as { roomId?: unknown }).roomId !== roomId) return;\n\n    handleSDP(conn, (payload as { SDP?: unknown }).SDP);\n    handleUserId(conn, (payload as { userId?: unknown }).userId);\n    handleMediaTypes(conn, (payload as { mediaTypes?: unknown }).mediaTypes);\n\n    if (Array.isArray((payload as { peers?: unknown }).peers)) {\n      (payload as { peers: unknown[] }).peers.forEach((peer) => {\n        if (isValidPeerId(roomId, peer)) {\n          connectPeer(peer);\n        }\n      });\n    }\n\n    const connUserId = connMap.getUserId(conn);\n    if (connUserId) {\n      const info: PeerInfo = {\n        userId: connUserId,\n        peerIndex: getPeerIndexFromConn(conn),\n        mediaTypes: connMap.getMediaTypes(conn),\n      };\n      try {\n        receiveData((payload as { data: unknown }).data, info);\n      } catch (e) {\n        console.error(\"receiveData\", e);\n      }\n    }\n  };\n\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnected(conn.peer)) {\n      conn.close();\n      return;\n    }\n    connMap.addConn(conn);\n    conn.on(\"open\", () => {\n      connMap.markConnected(conn);\n      showConnectedStatus();\n      if (lastBroadcastData) {\n        conn.send({\n          roomId,\n          userId,\n          data: lastBroadcastData,\n          peers: connMap.getConnectedPeerIds(),\n          mediaTypes,\n        });\n      }\n    });\n    conn.on(\"data\", (payload: unknown) => handlePayload(conn, payload));\n    conn.peerConnection.addEventListener(\"negotiationneeded\", async () => {\n      if (!connMap.isConnected(conn.peer)) return;\n      const offer = await conn.peerConnection.createOffer();\n      await conn.peerConnection.setLocalDescription(offer);\n      sendSDP(conn, { offer });\n    });\n    conn.peerConnection.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const connUserId = connMap.getUserId(conn);\n      if (connUserId) {\n        const info: PeerInfo = {\n          userId: connUserId,\n          peerIndex: getPeerIndexFromPeerId(conn.peer),\n          mediaTypes: connMap.getMediaTypes(conn),\n        };\n        receiveTrack(event.track, info);\n      }\n    });\n    conn.on(\"close\", () => {\n      connMap.delConn(conn);\n      console.log(\"dataConnection closed\", conn);\n      updateNetworkStatus({\n        type: \"CONNECTION_CLOSED\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      showConnectedStatus();\n      if (connMap.getConnectedPeerIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        guessSeed(conn.peer) &&\n        myPeer &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 30 + Math.floor(Math.random() * 60);\n        console.log(\n          `Disconnected seed peer: ${getPeerIndexFromPeerId(\n            conn.peer\n          )}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const initMyPeer = (index = MIN_SEED_PEER_INDEX) => {\n    if (disposed) return;\n    if (myPeer) return;\n    connMap.clearAll();\n    const isSeed = MIN_SEED_PEER_INDEX <= index && index <= MAX_SEED_PEER_INDEX;\n    const peerIndex = isSeed ? index : rand4();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex });\n    const id = generatePeerId(roomId, peerIndex);\n    console.log(\"initMyPeer start\", index, id);\n    const peer = new Peer(id, {\n      ...(getServerConfigFromUrl() || {}),\n      debug: 2,\n    });\n    myPeer = peer;\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      if (process.env.NODE_ENV !== \"production\") {\n        (window as any).myPeer = myPeer;\n      }\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const seedId = generatePeerId(roomId, i);\n        connectPeer(seedId);\n      }\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        myPeer = null;\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", index, err);\n        peer.destroy();\n      } else {\n        console.error(\"initMyPeer\", index, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\" });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (myPeer !== peer) {\n        conn.close();\n        return;\n      }\n      console.log(\"new connection received\", conn);\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", index);\n      setTimeout(() => {\n        if (myPeer === peer && !peer.destroyed) {\n          console.log(\"initMyPeer reconnecting\", index);\n          updateNetworkStatus({ type: \"RECONNECTING\" });\n          peer.reconnect();\n        }\n      }, 5 * 1000);\n    });\n    peer.on(\"close\", () => {\n      if (myPeer === peer) {\n        console.log(\"initMyPeer closed, re-initializing\", index);\n        myPeer = null;\n        setTimeout(initMyPeer, 10 * 1000);\n      } else {\n        console.log(\"initMyPeer closed, ignoring\", index);\n      }\n    });\n  };\n  initMyPeer();\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer) return;\n    if (myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      let existsAllSeeds = true;\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const id = generatePeerId(roomId, i);\n        if (!connMap.isConnected(id)) {\n          existsAllSeeds = false;\n          break;\n        }\n      }\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    const oldPeer = myPeer;\n    myPeer = null;\n    oldPeer.destroy();\n    initMyPeer();\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    mediaTypes = mTypes;\n    if (mediaTypes.length) {\n      if (!localStream) {\n        localStream = new MediaStream();\n      }\n    } else {\n      localStream = null;\n    }\n    broadcastData(null);\n  };\n\n  const trackMediaTypeMap = new WeakMap<MediaStreamTrack, string>();\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (!localStream) return;\n    trackMediaTypeMap.set(track, mediaType);\n    localStream.addTrack(track);\n    connMap.forEachConnsAcceptingMedia(mediaType, async (conn) => {\n      try {\n        if (!localStream) return;\n        conn.peerConnection.addTrack(track, localStream);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (localStream) {\n      localStream.removeTrack(track);\n    }\n    connMap.forEachConnsAcceptingMedia(mediaType, async (conn) => {\n      const senders = conn.peerConnection.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const syncTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    console.log(\"syncTracks: senders\", senders.length, conn);\n    const mTypes = connMap.getMediaTypes(conn);\n    if (localStream) {\n      localStream.getTracks().forEach((track) => {\n        const mType = trackMediaTypeMap.get(track);\n        if (\n          localStream &&\n          mType &&\n          mTypes.includes(mType) &&\n          senders.every((sender) => sender.track !== track)\n        ) {\n          conn.peerConnection.addTrack(track, localStream);\n        }\n      });\n    }\n    senders.forEach((sender) => {\n      if (sender.track) {\n        const mType = trackMediaTypeMap.get(sender.track);\n        if (!mType || !mTypes.includes(mType)) {\n          conn.peerConnection.removeTrack(sender);\n        }\n      }\n    });\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n    }\n  };\n\n  return {\n    broadcastData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","import { useEffect, useState, useCallback, useRef } from \"react\";\n\nimport { PeerInfo, createRoom, NetworkStatus } from \"../network/room\";\n\ntype NetworkStatusListener = (status: NetworkStatus) => void;\ntype DataListener = (data: unknown, info: PeerInfo) => void;\ntype TrackListener = {\n  mediaType: string;\n  listener: (track: MediaStreamTrack, info: PeerInfo) => void;\n};\ntype RoomEntry = {\n  room: ReturnType<typeof createRoom>;\n  networkStatusListeners: Set<NetworkStatusListener>;\n  dataListeners: Set<DataListener>;\n  trackListeners: Set<TrackListener>;\n  count: number;\n};\nconst roomEntryMap = new Map<string, RoomEntry>();\nconst register = (\n  roomId: string,\n  userId: string,\n  networkStatusListener?: NetworkStatusListener,\n  dataListener?: DataListener,\n  trackListener?: TrackListener\n) => {\n  const roomEntryKey = `${roomId}_${userId}`;\n  let entry = roomEntryMap.get(roomEntryKey);\n  if (!entry) {\n    const networkStatusListeners = new Set<NetworkStatusListener>();\n    const dataListeners = new Set<DataListener>();\n    const trackListeners = new Set<TrackListener>();\n    const updateNetworkStatus = (status: NetworkStatus) => {\n      networkStatusListeners.forEach((listener) => {\n        listener(status);\n      });\n    };\n    const receiveData = (data: unknown, info: PeerInfo) => {\n      dataListeners.forEach((listener) => {\n        listener(data, info);\n      });\n    };\n    const receiveTrack = (track: MediaStreamTrack, info: PeerInfo) => {\n      trackListeners.forEach(({ listener }) => {\n        listener(track, info);\n      });\n    };\n    const room = createRoom(\n      roomId,\n      userId,\n      updateNetworkStatus,\n      receiveData,\n      receiveTrack\n    );\n    entry = {\n      room,\n      networkStatusListeners,\n      dataListeners,\n      trackListeners,\n      count: 0,\n    };\n    roomEntryMap.set(roomEntryKey, entry);\n  }\n  if (networkStatusListener) {\n    entry.networkStatusListeners.add(networkStatusListener);\n  }\n  if (dataListener) {\n    entry.dataListeners.add(dataListener);\n  }\n  if (trackListener) {\n    const mediaTypeSet = new Set(\n      Array.from(entry.trackListeners).map((x) => x.mediaType)\n    );\n    const prevSize = mediaTypeSet.size;\n    entry.trackListeners.add(trackListener);\n    mediaTypeSet.add(trackListener.mediaType);\n    if (prevSize !== mediaTypeSet.size) {\n      entry.room.acceptMediaTypes(Array.from(mediaTypeSet));\n    }\n  }\n  entry.count += 1;\n  const definedEntry = entry;\n  const unregister = () => {\n    if (networkStatusListener) {\n      definedEntry.networkStatusListeners.delete(networkStatusListener);\n    }\n    if (dataListener) {\n      definedEntry.dataListeners.delete(dataListener);\n    }\n    if (trackListener) {\n      let mediaTypeSet = new Set(\n        Array.from(definedEntry.trackListeners).map((x) => x.mediaType)\n      );\n      const prevSize = mediaTypeSet.size;\n      definedEntry.trackListeners.delete(trackListener);\n      mediaTypeSet = new Set(\n        Array.from(definedEntry.trackListeners).map((x) => x.mediaType)\n      );\n      if (prevSize !== mediaTypeSet.size) {\n        definedEntry.room.acceptMediaTypes(Array.from(mediaTypeSet));\n      }\n    }\n    definedEntry.count -= 1;\n    if (definedEntry.count <= 0) {\n      definedEntry.room.dispose();\n      roomEntryMap.delete(roomEntryKey);\n    }\n  };\n  return {\n    broadcastData: entry.room.broadcastData,\n    addTrack: entry.room.addTrack,\n    removeTrack: entry.room.removeTrack,\n    unregister,\n  };\n};\n\nexport const useRoomNetworkStatus = (\n  roomId: string,\n  userId: string,\n  onNetworkStatus?: (networkStatus: NetworkStatus) => void\n) => {\n  const [networkStatus, updateNetworkStatus] = useState<NetworkStatus>();\n  if (networkStatus && networkStatus.type === \"UNKNOWN_ERROR\") {\n    throw new Error(\"Network Error\");\n  }\n  useEffect(() => {\n    const { unregister } = register(roomId, userId, (ns: NetworkStatus) => {\n      updateNetworkStatus(ns);\n      if (onNetworkStatus) onNetworkStatus(ns);\n    });\n    return unregister;\n  }, [roomId, userId, onNetworkStatus]);\n  return networkStatus;\n};\n\ntype BroadcastData = ReturnType<typeof createRoom>[\"broadcastData\"];\n\nexport const useBroadcastData = (roomId: string, userId: string) => {\n  const broadcastDataRef = useRef<BroadcastData>();\n  const broadcastData = useCallback((...args: Parameters<BroadcastData>) => {\n    if (broadcastDataRef.current) {\n      broadcastDataRef.current(...args);\n    } else {\n      // TODO pending queue\n    }\n  }, []);\n  useEffect(() => {\n    const registered = register(roomId, userId);\n    broadcastDataRef.current = registered.broadcastData;\n    return registered.unregister;\n  }, [roomId, userId]);\n  return broadcastData;\n};\n\nexport const useRoomData = (\n  roomId: string,\n  userId: string,\n  onRoomData: (data: unknown, info: PeerInfo) => void\n) => {\n  useEffect(() => {\n    const { unregister } = register(roomId, userId, undefined, onRoomData);\n    return unregister;\n  }, [roomId, userId, onRoomData]);\n};\n\nexport const useRoomMedia = (\n  roomId: string,\n  userId: string,\n  onTrack: (track: MediaStreamTrack, info: PeerInfo) => void,\n  mediaType?: string\n) => {\n  const [functions, setFunctions] = useState<{\n    addTrack?: (track: MediaStreamTrack) => void;\n    removeTrack?: (track: MediaStreamTrack) => void;\n  }>({});\n  useEffect(() => {\n    if (mediaType) {\n      const result = register(roomId, userId, undefined, undefined, {\n        mediaType,\n        listener: onTrack,\n      });\n      setFunctions({\n        addTrack: (track: MediaStreamTrack) =>\n          result.addTrack(mediaType, track),\n        removeTrack: (track: MediaStreamTrack) =>\n          result.removeTrack(mediaType, track),\n      });\n      return () => {\n        setFunctions({});\n        result.unregister();\n      };\n    }\n    return undefined;\n  }, [roomId, userId, onTrack, mediaType]);\n  return functions;\n};\n","type DeviceInfo = {\n  label: string;\n  deviceId: string;\n};\n\nexport const getVideoDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"videoinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n\nexport const getAudioDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"audioinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import { sleep } from \"../utils/sleep\";\n\nconst captureImage = async (stream: MediaStream, track: MediaStreamTrack) => {\n  if (typeof ImageCapture !== \"undefined\") {\n    const imageCapture = new ImageCapture(track);\n    await sleep(2000);\n    let srcImg;\n    try {\n      const blob = await imageCapture.takePhoto();\n      srcImg = await createImageBitmap(blob);\n    } catch (e) {\n      srcImg = await imageCapture.grabFrame();\n    }\n    const srcW = srcImg.width;\n    const srcH = srcImg.height;\n    return { srcImg, srcW, srcH };\n  }\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  const savedSrcObject = video.srcObject;\n  const revert = () => {\n    video.srcObject = savedSrcObject;\n  };\n  video.srcObject = stream;\n  await sleep(2000);\n  const srcImg = video;\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  return { srcImg, srcW, srcH, revert };\n};\n\nexport const takePhoto = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const track = stream.getVideoTracks()[0];\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const { srcImg, srcW, srcH, revert } = await captureImage(stream, track);\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  ctx.drawImage(srcImg, x, y, width, height, 0, 0, dstW, dstH);\n  if (revert) {\n    revert();\n  }\n  track.stop();\n  return canvas.toDataURL(\"image/png\");\n};\n","import { sleep } from \"../utils/sleep\";\n\nexport const getVideoStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const track = stream.getVideoTracks()[0];\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  video.srcObject = stream;\n  await sleep(1000);\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  const timer = setInterval(() => {\n    ctx.drawImage(video, x, y, width, height, 0, 0, dstW, dstH);\n  }, 1000 / 30);\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const dispose = () => {\n    video.style.display = \"none\";\n    clearInterval(timer);\n    track.stop();\n    canvasStream.getVideoTracks()[0].stop();\n  };\n  return {\n    stream: canvasStream,\n    dispose,\n  };\n};\n\nconst checkVideTrackFaceSize = async (track: MediaStreamTrack) => {\n  try {\n    const video = document.createElement(\"video\");\n    video.srcObject = new MediaStream([track]);\n    for (let i = 0; i < 50; i += 1) {\n      // eslint-disable-next-line no-await-in-loop\n      await sleep(100);\n      const width = video.videoWidth;\n      const height = video.videoHeight;\n      if (width > 0 && height > 0) {\n        return width === 72 && height === 72;\n      }\n    }\n    return true; // fallback to true\n  } catch (e) {\n    return true; // fallback to true\n  }\n};\n\nconst videoTrackFaceSizeMap = new WeakMap<MediaStreamTrack, Promise<boolean>>();\n\nexport const isVideoTrackFaceSize = (track: MediaStreamTrack) => {\n  if (videoTrackFaceSizeMap.has(track)) {\n    return videoTrackFaceSizeMap.get(track) as Promise<boolean>;\n  }\n  const promise = checkVideTrackFaceSize(track);\n  videoTrackFaceSizeMap.set(track, promise);\n  return promise;\n};\n","export const getAudioStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        audio: { deviceId },\n      }\n    : { audio: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const track = stream.getAudioTracks()[0];\n  await track.applyConstraints({\n    echoCancellation: true,\n    echoCancellationType: { ideal: \"system\" },\n    noiseSuppression: { ideal: true },\n  } as MediaTrackConstraints);\n  const dispose = () => {\n    track.stop();\n  };\n  return {\n    stream,\n    dispose,\n  };\n};\n","import { useCallback, useEffect, useState, useRef } from \"react\";\n\nimport { getVideoStream, isVideoTrackFaceSize } from \"../media/video\";\nimport { getAudioStream } from \"../media/audio\";\nimport { useRoomMedia } from \"./useRoom\";\n\nconst addTrackWithNewStream = (\n  track: MediaStreamTrack,\n  stream: MediaStream | null\n) => {\n  const prevVideoTrack = stream && stream.getVideoTracks()[0];\n  const prevAudioTrack = stream && stream.getAudioTracks()[0];\n  const newStream = new MediaStream();\n  newStream.addTrack(track);\n  if (track.kind === \"video\" && prevAudioTrack) {\n    newStream.addTrack(prevAudioTrack);\n  } else if (track.kind === \"audio\" && prevVideoTrack) {\n    newStream.addTrack(prevVideoTrack);\n  }\n  return newStream;\n};\n\nconst removeTrackWithNewStream = (\n  track: MediaStreamTrack,\n  stream: MediaStream | null\n) => {\n  const prevVideoTrack = stream && stream.getVideoTracks()[0];\n  const prevAudioTrack = stream && stream.getAudioTracks()[0];\n  const newStream = new MediaStream();\n  if (track.kind === \"video\" && prevAudioTrack) {\n    newStream.addTrack(prevAudioTrack);\n  } else if (track.kind === \"audio\" && prevVideoTrack) {\n    newStream.addTrack(prevVideoTrack);\n  }\n  if (newStream.getTracks().length > 0) {\n    return newStream;\n  }\n  return null;\n};\n\nexport const useFaceVideos = (\n  roomId: string,\n  userId: string,\n  videoEnabled: boolean,\n  audioEnabled: boolean,\n  micOn: boolean,\n  videoDeviceId?: string,\n  audioDeviceId?: string\n) => {\n  const [faceStream, setFaceStream] = useState<MediaStream | null>(null);\n  const [faceStreamMap, setFaceStreamMap] = useState<{\n    [userId: string]: MediaStream | null;\n  }>({});\n\n  type CleanupFn = () => void;\n  const cleanupFns = useRef<CleanupFn[]>([]);\n  useEffect(() => {\n    const cleanup = () => {\n      cleanupFns.current.forEach((fn) => fn());\n    };\n    return cleanup;\n  }, []);\n\n  const onTrack = useCallback(async (track, info) => {\n    if (track.kind === \"video\" && !(await isVideoTrackFaceSize(track))) {\n      return;\n    }\n    setFaceStreamMap((prev) => ({\n      ...prev,\n      [info.userId]: addTrackWithNewStream(track, prev[info.userId]),\n    }));\n    const onended = () => {\n      setFaceStreamMap((prev) => ({\n        ...prev,\n        [info.userId]: removeTrackWithNewStream(track, prev[info.userId]),\n      }));\n    };\n    track.addEventListener(\"ended\", onended);\n    cleanupFns.current.push(() => {\n      track.removeEventListener(\"ended\", onended);\n    });\n  }, []);\n\n  const {\n    addTrack: addVideoTrack,\n    removeTrack: removeVideoTrack,\n  } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    videoEnabled ? \"faceVideo\" : undefined\n  );\n\n  const {\n    addTrack: addAudioTrack,\n    removeTrack: removeAudioTrack,\n  } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    audioEnabled ? \"faceAudio\" : undefined\n  );\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (videoEnabled && addVideoTrack && removeVideoTrack) {\n      (async () => {\n        const {\n          stream: videoStream,\n          dispose: disposeVideo,\n        } = await getVideoStream(videoDeviceId);\n        const videoTrack = videoStream.getVideoTracks()[0];\n        addVideoTrack(videoTrack);\n        setFaceStream((prev) => addTrackWithNewStream(videoTrack, prev));\n        dispose = () => {\n          setFaceStream((prev) => removeTrackWithNewStream(videoTrack, prev));\n          removeVideoTrack(videoTrack);\n          disposeVideo();\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, videoEnabled, videoDeviceId, addVideoTrack, removeVideoTrack]);\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (audioEnabled && addAudioTrack && removeAudioTrack) {\n      (async () => {\n        const {\n          stream: audioStream,\n          dispose: disposeAudio,\n        } = await getAudioStream(audioDeviceId);\n        const audioTrack = audioStream.getAudioTracks()[0];\n        addAudioTrack(audioTrack);\n        setFaceStream((prev) => addTrackWithNewStream(audioTrack, prev));\n        dispose = () => {\n          setFaceStream((prev) => removeTrackWithNewStream(audioTrack, prev));\n          removeAudioTrack(audioTrack);\n          disposeAudio();\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, audioEnabled, audioDeviceId, addAudioTrack, removeAudioTrack]);\n  useEffect(() => {\n    if (faceStream) {\n      const audioTrack = faceStream.getAudioTracks()[0];\n      if (audioTrack) {\n        audioTrack.enabled = micOn;\n      }\n    }\n  }, [faceStream, micOn]);\n\n  return { faceStream, faceStreamMap };\n};\n","import React from \"react\";\n\nimport \"./FaceImages.css\";\nimport { useFaceImages } from \"../hooks/useFaceImages\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\n\nconst BLANK_IMAGE =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQI12NgYAAAAAMAASDVlMcAAAAASUVORK5CYII=\";\n\nconst FaceImage = React.memo<{\n  image?: string;\n  nickname: string;\n  statusMesg: string;\n  obsoleted?: boolean;\n  liveMode?: boolean;\n  stream?: MediaStream;\n  speakerOn?: boolean;\n}>(\n  ({ image, nickname, statusMesg, obsoleted, liveMode, stream, speakerOn }) => (\n    <div className=\"FaceImages-card\" style={{ opacity: obsoleted ? 0.2 : 1 }}>\n      {liveMode && stream ? (\n        <video\n          className=\"FaceImages-photo\"\n          ref={(videoEle) => {\n            if (videoEle) {\n              // eslint-disable-next-line no-param-reassign\n              videoEle.srcObject = stream;\n            }\n          }}\n          autoPlay\n          muted={!speakerOn}\n        />\n      ) : (\n        <img\n          src={image || BLANK_IMAGE}\n          className=\"FaceImages-photo\"\n          alt=\"myself\"\n        />\n      )}\n      <div className=\"FaceImages-name\">{nickname}</div>\n      <div className=\"FaceImages-mesg\">{statusMesg}</div>\n      {liveMode && stream && (\n        <div className=\"FaceImages-live-indicator\" title=\"Live Mode On\">\n          &#9673;\n        </div>\n      )}\n      {liveMode && !stream && !obsoleted && (\n        <div className=\"FaceImages-live-indicator\" title=\"Live Mode Available\">\n          &#9678;\n        </div>\n      )}\n    </div>\n  )\n);\n\ntype Props = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n  statusMesg: string;\n  liveMode: boolean;\n  micOn: boolean;\n  speakerOn: boolean;\n  videoDeviceId?: string;\n  audioDeviceId?: string;\n};\n\nconst FaceImages: React.FC<Props> = ({\n  roomId,\n  userId,\n  nickname,\n  statusMesg,\n  liveMode,\n  micOn,\n  speakerOn,\n  videoDeviceId,\n  audioDeviceId,\n}) => {\n  const { myImage, roomImages } = useFaceImages(\n    roomId,\n    userId,\n    nickname,\n    statusMesg,\n    liveMode,\n    videoDeviceId\n  );\n  const { faceStream, faceStreamMap } = useFaceVideos(\n    roomId,\n    userId,\n    liveMode,\n    liveMode,\n    micOn,\n    videoDeviceId,\n    audioDeviceId\n  );\n\n  return (\n    <div className=\"FaceImage-container\">\n      <FaceImage\n        image={myImage}\n        nickname={nickname}\n        statusMesg={statusMesg}\n        liveMode={liveMode}\n        stream={faceStream || undefined}\n      />\n      {roomImages.map((item) => (\n        <FaceImage\n          key={item.userId}\n          image={item.image}\n          nickname={item.info.nickname}\n          statusMesg={item.info.message}\n          obsoleted={item.obsoleted}\n          liveMode={item.info.liveMode}\n          stream={faceStreamMap[item.userId] || undefined}\n          speakerOn={speakerOn}\n        />\n      ))}\n    </div>\n  );\n};\n\nexport default React.memo(FaceImages);\n","import { useCallback, useEffect, useState } from \"react\";\n\nimport { takePhoto } from \"../media/capture\";\nimport { useRoomData, useBroadcastData, useRoomNetworkStatus } from \"./useRoom\";\n\ntype ImageUrl = string;\ntype FaceInfo = {\n  nickname: string;\n  message: string;\n  liveMode: boolean;\n};\ntype ImageData = {\n  image: ImageUrl;\n  info: FaceInfo;\n};\ntype RoomImage = ImageData & {\n  userId: string;\n  received: number; // in milliseconds\n  obsoleted: boolean;\n  peerIndex: number;\n};\n\nconst isFaceInfo = (x: unknown): x is FaceInfo =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { message: unknown }).message === \"string\" &&\n  typeof (x as { liveMode: unknown }).liveMode === \"boolean\";\n\nconst isImageData = (x: unknown): x is ImageData =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { image: unknown }).image === \"string\" &&\n  isFaceInfo((x as { info: unknown }).info);\n\nexport const useFaceImages = (\n  roomId: string,\n  userId: string,\n  nickname: string,\n  statusMesg: string,\n  liveMode: boolean,\n  deviceId?: string\n) => {\n  const [myImage, setMyImage] = useState<ImageUrl>();\n  const [roomImages, setRoomImages] = useState<RoomImage[]>([]);\n  const [fatalError, setFatalError] = useState<Error>();\n\n  if (fatalError) {\n    throw fatalError;\n  }\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  useRoomData(\n    roomId,\n    userId,\n    useCallback((data, info) => {\n      if (!isImageData(data)) return;\n      const roomImage = {\n        ...data,\n        userId: info.userId,\n        received: Date.now(),\n        obsoleted: false,\n        peerIndex: info.peerIndex,\n      };\n      setRoomImages((prev) => {\n        const found = prev.find((item) => item.userId === roomImage.userId);\n        if (!found) {\n          return [...prev, roomImage];\n        }\n        return prev.map((item) =>\n          item.userId === roomImage.userId ? roomImage : item\n        );\n      });\n    }, [])\n  );\n\n  useRoomNetworkStatus(\n    roomId,\n    userId,\n    useCallback((networkStatus) => {\n      if (networkStatus && networkStatus.type === \"CONNECTION_CLOSED\") {\n        const { peerIndex } = networkStatus;\n        setRoomImages((prev) => {\n          let changed = false;\n          const next = prev.map((item) => {\n            if (item.peerIndex === peerIndex) {\n              changed = true;\n              return { ...item, obsoleted: true };\n            }\n            return item;\n          });\n          return changed ? next : prev;\n        });\n      }\n    }, [])\n  );\n\n  useEffect(() => {\n    const checkObsoletedImage = () => {\n      const twoMinAgo = Date.now() - 2 * 60 * 1000;\n      const tenMinAgo = Date.now() - 10 * 60 * 1000;\n      setRoomImages((prev) => {\n        let changed = false;\n        const next = prev\n          .map((item) => {\n            if (item.received < twoMinAgo && !item.obsoleted) {\n              changed = true;\n              return { ...item, obsoleted: true };\n            }\n            if (item.received < tenMinAgo && item.obsoleted) {\n              changed = true;\n              return null;\n            }\n            return item;\n          })\n          .filter((item) => item) as typeof prev;\n\n        return changed ? next : prev;\n      });\n    };\n    const loop = async () => {\n      try {\n        checkObsoletedImage();\n        const image = await takePhoto(deviceId);\n        setMyImage(image);\n        const info: FaceInfo = { nickname, message: statusMesg, liveMode };\n        const data = {\n          userId,\n          image,\n          info,\n        };\n        broadcastData(data, true);\n      } catch (e) {\n        console.error(e);\n        setFatalError(e);\n      }\n    };\n    loop();\n    const timer = setInterval(loop, 2 * 60 * 1000);\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [roomId, userId, deviceId, nickname, statusMesg, liveMode, broadcastData]);\n\n  return {\n    myImage,\n    roomImages,\n  };\n};\n","import { useState, useCallback, useRef } from \"react\";\n\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\nconst MAX_CHAT_LIST_SIZE = 100;\n\ntype ChatData = {\n  userId: string;\n  nickname: string;\n  chatSeq: number;\n  chatText: string;\n  chatInReplyTo?: {\n    userId: string;\n    chatSeq: number;\n  };\n};\n\nconst isChatData = (x: unknown): x is ChatData =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { userId: unknown }).userId === \"string\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { chatSeq: unknown }).chatSeq === \"number\" &&\n  typeof (x as { chatText: unknown }).chatText === \"string\" &&\n  (typeof (x as { chatInReplyTo: unknown }).chatInReplyTo === \"undefined\" ||\n    typeof (x as { chatInReplyTo: { userId: unknown } }).chatInReplyTo\n      .userId === \"string\" ||\n    typeof (x as { chatInReplyTo: { chatSeq: unknown } }).chatInReplyTo\n      .chatSeq === \"number\");\n\ntype Reply = [string, number];\n\ntype ChatItem = {\n  key: string;\n  replyTo: { userId: string; chatSeq: number };\n  nickname: string;\n  text: string;\n  replies: Reply[];\n};\n\nconst compareReply = (a: Reply, b: Reply) => {\n  const countDiff = b[1] - a[1];\n  if (countDiff === 0) {\n    return a[0].length - b[0].length;\n  }\n  return countDiff;\n};\n\nexport const useMomentaryChat = (\n  roomId: string,\n  userId: string,\n  nickname: string\n) => {\n  const chatSeqRef = useRef(1);\n  const receivedSeqMap = useRef(new Map<string, number>());\n  const [chatList, setChatList] = useState<ChatItem[]>([]);\n\n  const addChatItem = useCallback((chatData: ChatData) => {\n    if ((receivedSeqMap.current.get(chatData.userId) || 0) < chatData.chatSeq) {\n      receivedSeqMap.current.set(chatData.userId, chatData.chatSeq);\n    } else {\n      return;\n    }\n    if (chatData.chatInReplyTo) {\n      const { chatText, chatInReplyTo } = chatData;\n      setChatList((prev) =>\n        prev.map((item) => {\n          if (\n            item.replyTo.userId === chatInReplyTo.userId &&\n            item.replyTo.chatSeq === chatInReplyTo.chatSeq\n          ) {\n            const replyMap = new Map(item.replies);\n            replyMap.set(chatText, (replyMap.get(chatText) || 0) + 1);\n            const replies = [...replyMap.entries()];\n            replies.sort(compareReply);\n            return { ...item, replies };\n          }\n          return item;\n        })\n      );\n    } else {\n      const chatItem: ChatItem = {\n        key: `${chatData.userId}_${chatData.chatSeq}`,\n        replyTo: {\n          userId: chatData.userId,\n          chatSeq: chatData.chatSeq,\n        },\n        nickname: chatData.nickname,\n        text: chatData.chatText,\n        replies: [],\n      };\n      setChatList((prev) => [chatItem, ...prev].slice(0, MAX_CHAT_LIST_SIZE));\n    }\n  }, []);\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data) => {\n        if (!isChatData(data)) return;\n        addChatItem(data);\n      },\n      [addChatItem]\n    )\n  );\n\n  const sendChat = useCallback(\n    (text: string) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  const replyChat = useCallback(\n    (text: string, inReplyTo: { userId: string; chatSeq: number }) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n        chatInReplyTo: inReplyTo,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  return {\n    chatList,\n    sendChat,\n    replyChat,\n  };\n};\n","import React, { useState } from \"react\";\n\nimport \"./MomentaryChat.css\";\nimport { useMomentaryChat } from \"../hooks/useMomentaryChat\";\n\ntype ChatList = ReturnType<typeof useMomentaryChat>[\"chatList\"];\ntype ReplyChat = ReturnType<typeof useMomentaryChat>[\"replyChat\"];\n\nconst reactions = [\"👍\", \"❤️\", \"😁\", \"😎\", \"🤣\"];\n\nconst ReactionButton: React.FC<{\n  text: string;\n  onClick: (text: string) => void;\n}> = ({ text, onClick }) => (\n  <button type=\"button\" onClick={() => onClick(text)}>\n    <span aria-label=\"Reaction\">{text}</span>\n  </button>\n);\n\nconst MomentaryChatContent = React.memo<{\n  chatList: ChatList;\n  replyChat: ReplyChat;\n}>(({ chatList, replyChat }) => (\n  <ul className=\"MomentaryChat-list\">\n    {chatList.map((item) => {\n      const reply = (text: string) => replyChat(text, item.replyTo);\n      return (\n        <li key={item.key} className=\"MomentaryChat-listPart\">\n          <div className=\"MomentaryChat-listPart-header\">\n            <div className=\"MomentaryChat-iconButton-container\">\n              <div className=\"MomentaryChat-iconButton\">\n                {reactions.map((text) => (\n                  <ReactionButton key={text} text={text} onClick={reply} />\n                ))}\n              </div>\n            </div>\n            <div className=\"MomentaryChat-nickname\">\n              {item.nickname || \"No Name\"}\n            </div>\n          </div>\n          <div>{item.text}</div>\n          {item.replies.map(([text, count]) => (\n            <div className=\"Momentary-icon\">\n              {text} {count}\n            </div>\n          ))}\n        </li>\n      );\n    })}\n  </ul>\n));\n\ntype Props = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n};\n\nconst MomentaryChat: React.FC<Props> = ({ roomId, userId, nickname }) => {\n  const { chatList, sendChat, replyChat } = useMomentaryChat(\n    roomId,\n    userId,\n    nickname\n  );\n\n  const [text, setText] = useState(\"\");\n  const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    if (text) {\n      sendChat(text);\n      setText(\"\");\n    }\n  };\n\n  return (\n    <div className=\"MomentaryChat-container\">\n      <form onSubmit={onSubmit}>\n        <input\n          value={text}\n          onChange={(e) => setText(e.target.value)}\n          placeholder=\"Enter chat message\"\n        />\n        <button type=\"submit\" disabled={!text}>\n          Send\n        </button>\n      </form>\n      <MomentaryChatContent chatList={chatList} replyChat={replyChat} />\n    </div>\n  );\n};\n\nexport default React.memo(MomentaryChat);\n","export const getScreenStream = async () => {\n  try {\n    const constraints = { video: true };\n    const stream = (await (navigator.mediaDevices as any).getDisplayMedia(\n      constraints\n    )) as MediaStream;\n    const track = stream.getVideoTracks()[0];\n    const dispose = () => {\n      track.stop();\n    };\n    return {\n      stream,\n      dispose,\n    };\n  } catch (e) {\n    return null;\n  }\n};\n","import { useCallback, useEffect, useState, useRef } from \"react\";\n\nimport { isVideoTrackFaceSize } from \"../media/video\";\nimport { getScreenStream } from \"../media/screen\";\nimport { useRoomMedia } from \"./useRoom\";\n\nconst isScreenTrack = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") return false;\n  const isFaceSize = await isVideoTrackFaceSize(track);\n  return !isFaceSize;\n};\n\nexport const useScreenShare = (\n  roomId: string,\n  userId: string,\n  enabled: boolean,\n  setEnabled: (enabled: boolean) => void\n) => {\n  const [screenStream, setScreenStream] = useState<MediaStream | null>(null);\n  const [screenStreamMap, setScreenStreamMap] = useState<{\n    [userId: string]: MediaStream | null;\n  }>({});\n\n  type CleanupFn = () => void;\n  const cleanupFns = useRef<CleanupFn[]>([]);\n  useEffect(() => {\n    const cleanup = () => {\n      cleanupFns.current.forEach((fn) => fn());\n    };\n    return cleanup;\n  }, []);\n\n  const onTrack = useCallback(async (track, info) => {\n    if (!(await isScreenTrack(track))) return;\n    setScreenStreamMap((prev) => ({\n      ...prev,\n      [info.userId]: new MediaStream([track]),\n    }));\n    const onended = () => {\n      setScreenStreamMap((prev) => ({\n        ...prev,\n        [info.userId]: null,\n      }));\n    };\n    track.addEventListener(\"ended\", onended);\n    // XXX we don't get \"ended\" event with removeTrack,\n    // so a workaround with \"mute\" but \"mute\" is dispatched occasionally,\n    // so use this timeout hack\n    let timeout: NodeJS.Timeout;\n    const onmute = () => {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        setScreenStreamMap((prev) => ({\n          ...prev,\n          [info.userId]: null,\n        }));\n      }, 3000);\n    };\n    track.addEventListener(\"mute\", onmute);\n    const onunmute = () => {\n      clearTimeout(timeout);\n    };\n    track.addEventListener(\"unmute\", onunmute);\n    cleanupFns.current.push(() => {\n      track.removeEventListener(\"ended\", onended);\n      clearTimeout(timeout);\n      track.removeEventListener(\"mute\", onmute);\n      track.removeEventListener(\"unmute\", onunmute);\n    });\n  }, []);\n\n  const { addTrack, removeTrack } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    \"screenVideo\"\n  );\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (enabled && addTrack && removeTrack) {\n      (async () => {\n        const result = await getScreenStream();\n        if (!result) {\n          setEnabled(false);\n          return;\n        }\n        const track = result.stream.getVideoTracks()[0];\n        (track as any).contentHint = \"screen\";\n        addTrack(track);\n        setScreenStream(result.stream);\n        dispose = () => {\n          removeTrack(track);\n          result.dispose();\n          setScreenStream(null);\n          setEnabled(false);\n        };\n        track.addEventListener(\"ended\", () => {\n          if (dispose) dispose();\n          dispose = null;\n        });\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, enabled, setEnabled, addTrack, removeTrack]);\n\n  return { screenStream, screenStreamMap };\n};\n","import React, { useState, useRef, useEffect } from \"react\";\n\nimport \"./ScreenShare.css\";\nimport { useScreenShare } from \"../hooks/useScreenShare\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\n\nconst Screen = React.memo<{\n  nickname: string;\n  stream: MediaStream;\n}>(({ nickname, stream }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  useEffect(() => {\n    if (stream && videoRef.current) {\n      videoRef.current.srcObject = stream;\n    }\n  }, [stream]);\n  return (\n    <div>\n      <div className=\"ScreenShare-nickname\">{nickname}</div>\n      <video className=\"ScreenShare-video\" ref={videoRef} autoPlay muted />\n    </div>\n  );\n});\n\ntype Props = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n};\n\nconst ScreenShare: React.FC<Props> = ({ roomId, userId, nickname }) => {\n  const [enabled, setEnabled] = useState(false);\n  const { screenStream, screenStreamMap } = useScreenShare(\n    roomId,\n    userId,\n    enabled,\n    setEnabled\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n\n  return (\n    <div className=\"ScreenShare-container\">\n      <button type=\"button\" onClick={() => setEnabled(!enabled)}>\n        {enabled ? \"Stop screen share\" : \"Start screen share\"}\n      </button>\n      {screenStream && <Screen nickname={nickname} stream={screenStream} />}\n      {Object.keys(screenStreamMap).map((screenUserId) => {\n        const stream = screenStreamMap[screenUserId];\n        if (!stream) return null;\n        return (\n          <Screen\n            key={screenUserId}\n            nickname={nicknameMap[screenUserId] || \"No Name\"}\n            stream={stream}\n          />\n        );\n      })}\n    </div>\n  );\n};\n\nexport default React.memo(ScreenShare);\n","import { useCallback, useState } from \"react\";\n\nimport { useRoomData } from \"./useRoom\";\n\ntype ImageUrl = string;\ntype FaceInfo = {\n  nickname: string;\n  message: string;\n};\ntype ImageData = {\n  image: ImageUrl;\n  info: FaceInfo;\n};\n\nconst isFaceInfo = (x: unknown): x is FaceInfo =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { message: unknown }).message === \"string\";\n\nconst isImageData = (x: unknown): x is ImageData =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { image: unknown }).image === \"string\" &&\n  isFaceInfo((x as { info: unknown }).info);\n\nexport const useNicknameMap = (roomId: string, userId: string) => {\n  const [nicknameMap, setNicknameMap] = useState<{\n    [userId: string]: string;\n  }>({});\n  useRoomData(\n    roomId,\n    userId,\n    useCallback((data, info) => {\n      if (!isImageData(data)) return;\n      setNicknameMap((prev) => ({\n        ...prev,\n        [info.userId]: data.info.nickname,\n      }));\n    }, [])\n  );\n  return nicknameMap;\n};\n","import React, { useEffect, useState } from \"react\";\n\nimport \"./SingleRoom.css\";\nimport { setRoomIdToUrl } from \"../utils/url\";\nimport { setStringItem, getStringItem } from \"../utils/storage\";\nimport { useRoomNetworkStatus } from \"../hooks/useRoom\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport FaceImages from \"./FaceImages\";\nimport MomentaryChat from \"./MomentaryChat\";\nimport ScreenShare from \"./ScreenShare\";\nimport {\n  Emoji,\n  EmojiPicker,\n  EmojiDataType,\n  isEmojiDataType,\n} from \"../utils/emoji\";\n\ntype Props = {\n  roomId: string;\n  userId: string;\n};\n\nconst initialNickname = getStringItem(\"nickname\");\n\nconst TextField = React.memo<{\n  initialText: string;\n  onUpdate: (text: string) => void;\n  buttonLabel?: string;\n  placeholder?: string;\n  clearOnUpdate?: boolean;\n}>(({ initialText, onUpdate, buttonLabel, placeholder, clearOnUpdate }) => {\n  const [text, setText] = useState(initialText);\n  const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    if (text) {\n      onUpdate(text);\n      if (clearOnUpdate) {\n        setText(\"\");\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={onSubmit}>\n      <input\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n        placeholder={placeholder}\n      />\n      {buttonLabel && (\n        <button type=\"submit\" disabled={!text}>\n          {buttonLabel}\n        </button>\n      )}\n    </form>\n  );\n});\n\nconst SingleRoom: React.FC<Props> = ({ roomId, userId }) => {\n  const [nickname, setNickname] = useState(initialNickname);\n  const [statusMesg, setStatusMesg] = useState(\"\");\n  const [emoji, setEmoji] = useState<EmojiDataType | null>(null);\n  const [openEmojiPicker, setOpenEmojiPicker] = useState(false);\n  useEffect(() => {\n    setRoomIdToUrl(roomId);\n  }, [roomId]);\n\n  const videoDevices = useVideoDevices();\n  const audioDevices = useAudioDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>();\n  const [audioDeviceId, setAudioDeviceId] = useState<string>();\n  const [liveMode, setLiveMode] = useState(false);\n  const [micOn, setMicOn] = useState(false);\n  const [speakerOn, setSpeakerOn] = useState(false);\n  const [screenShareMode, setScreenShareMode] = useState(false);\n  const [configOpen, setConfigOpen] = useState<boolean>(true);\n\n  const networkStatus = useRoomNetworkStatus(roomId, userId);\n\n  const appLink = `remote-faces://${window.location.href.replace(\n    /^https:\\/\\//,\n    \"\"\n  )}`;\n\n  return (\n    <>\n      <div className=\"SingleRoom-status\">{JSON.stringify(networkStatus)}</div>\n      <div className=\"SingleRoom-room-info\">\n        {configOpen ? (\n          <>\n            <button type=\"button\" onClick={() => setConfigOpen(false)}>\n              Hide config\n            </button>\n            <div>\n              Link to this room:\n              <input value={window.location.href} readOnly />\n              (Share this link with your colleagues)\n              <a href={appLink}>Open App</a>\n            </div>\n            <div className=\"SingleRoom-nickname\">\n              Your Name:{\" \"}\n              <TextField\n                initialText={initialNickname}\n                onUpdate={(text) => {\n                  setNickname(text);\n                  setStringItem(\"nickname\", text);\n                }}\n                placeholder=\"Enter your name\"\n                buttonLabel=\"Set\"\n              />\n            </div>\n            <div className=\"SingleRoom-statusmesg\">\n              Your Status:{\" \"}\n              <TextField\n                initialText=\"\"\n                onUpdate={(text) => {\n                  setStatusMesg(text);\n                }}\n                placeholder=\"Enter status message\"\n                buttonLabel=\"Set\"\n              />\n            </div>\n            <div className=\"SingleRoom-emoji\">\n              Your Emoji:{\" \"}\n              <button\n                type=\"button\"\n                onClick={() => {\n                  setOpenEmojiPicker(!openEmojiPicker);\n                }}\n              >\n                {emoji ? <Emoji emoji={emoji} size={16} /> : \"(Not Set)\"}\n              </button>\n              <button\n                type=\"button\"\n                onClick={() => {\n                  setEmoji(null);\n                  setOpenEmojiPicker(false);\n                }}\n              >\n                Clear\n              </button>\n            </div>\n            {openEmojiPicker && (\n              <EmojiPicker\n                onSelect={(e) => {\n                  if (isEmojiDataType(e)) {\n                    setEmoji(e);\n                  }\n                  setOpenEmojiPicker(false);\n                }}\n              />\n            )}\n            <div>\n              Select Camera:{\" \"}\n              <select onChange={(e) => setVideoDeviceId(e.target.value)}>\n                {videoDevices.map((videoDevice) => (\n                  <option\n                    key={videoDevice.deviceId}\n                    value={videoDevice.deviceId}\n                  >\n                    {videoDevice.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              Select Mic:{\" \"}\n              <select onChange={(e) => setAudioDeviceId(e.target.value)}>\n                {audioDevices.map((audioDevice) => (\n                  <option\n                    key={audioDevice.deviceId}\n                    value={audioDevice.deviceId}\n                  >\n                    {audioDevice.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              Live Mode:{\" \"}\n              <button type=\"button\" onClick={() => setLiveMode((x) => !x)}>\n                {liveMode\n                  ? \"Disable Live Mode (currently on)\"\n                  : \"Enable Live Mode (currently off)\"}\n              </button>\n              {liveMode && (\n                <>\n                  <label>\n                    <input\n                      type=\"checkbox\"\n                      checked={micOn}\n                      onChange={(e) => setMicOn(e.target.checked)}\n                    />\n                    Mic On\n                  </label>\n                  <label>\n                    <input\n                      type=\"checkbox\"\n                      checked={speakerOn}\n                      onChange={(e) => setSpeakerOn(e.target.checked)}\n                    />\n                    Speaker On\n                  </label>\n                </>\n              )}\n            </div>\n            <div>\n              Screen Share:{\" \"}\n              <button\n                type=\"button\"\n                onClick={() => setScreenShareMode((x) => !x)}\n              >\n                {screenShareMode\n                  ? \"Disable Screen Share (currently on)\"\n                  : \"Enable Screen Share (currently off)\"}\n              </button>\n            </div>\n          </>\n        ) : (\n          <button type=\"button\" onClick={() => setConfigOpen(true)}>\n            Show config\n          </button>\n        )}\n      </div>\n      <FaceImages\n        roomId={roomId}\n        userId={userId}\n        videoDeviceId={videoDeviceId}\n        audioDeviceId={audioDeviceId}\n        nickname={nickname}\n        statusMesg={`${emoji?.native || \"\"}${statusMesg}`}\n        liveMode={liveMode}\n        micOn={micOn}\n        speakerOn={speakerOn}\n      />\n      <MomentaryChat roomId={roomId} userId={userId} nickname={nickname} />\n      {screenShareMode && (\n        <ScreenShare roomId={roomId} userId={userId} nickname={nickname} />\n      )}\n    </>\n  );\n};\n\nexport default SingleRoom;\n","type StringItemName = \"nickname\" | \"TODO1\";\n\ntype JsonItemName = \"TODO2\" | \"TODO3\";\n\nexport const setStringItem = (name: StringItemName, value: string) => {\n  try {\n    window.localStorage.setItem(name, value);\n  } catch (e) {\n    console.log(\"Failed to save string to localStorage\", e);\n  }\n};\n\nexport const getStringItem = (name: StringItemName) => {\n  try {\n    return window.localStorage.getItem(name) || \"\";\n  } catch (e) {\n    // ignore\n    return \"\";\n  }\n};\n\nexport const setJsonItem = (name: JsonItemName, value: unknown) => {\n  try {\n    window.localStorage.setItem(name, JSON.stringify(value));\n  } catch (e) {\n    console.log(\"Failed to save json to localStorage\", e);\n  }\n};\n\nexport const getJsonItem = (name: JsonItemName): unknown | null => {\n  try {\n    return JSON.parse(window.localStorage.getItem(name) || \"\");\n  } catch (e) {\n    // ignore\n    return null;\n  }\n};\n\nexport const removeItem = (name: StringItemName | JsonItemName) => {\n  try {\n    window.localStorage.removeItem(name);\n  } catch (e) {\n    // ignore\n  }\n};\n","import { useEffect, useState } from \"react\";\n\nimport {\n  getVideoDeviceInfoList,\n  getAudioDeviceInfoList,\n} from \"../media/devices\";\n\ntype VideoDeviceInfoList = ReturnType<\n  typeof getVideoDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useVideoDevices = () => {\n  const [devices, setDevices] = useState<VideoDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getVideoDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n\ntype AudioDeviceInfoList = ReturnType<\n  typeof getAudioDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useAudioDevices = () => {\n  const [devices, setDevices] = useState<AudioDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getAudioDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n","import \"emoji-mart/css/emoji-mart.css\";\nimport { BaseEmoji } from \"emoji-mart\";\n\nexport { Emoji, Picker as EmojiPicker } from \"emoji-mart\";\nexport type EmojiDataType = BaseEmoji;\n\nexport const isEmojiDataType = (\n  emojiData: unknown\n): emojiData is EmojiDataType => {\n  try {\n    const { id } = emojiData as EmojiDataType;\n    if (typeof id === \"string\") return true;\n    return false;\n  } catch (e) {\n    return false;\n  }\n};\n","import React, { useState } from \"react\";\n\nimport \"./SingleRoomEntrance.css\";\nimport { secureRandomId } from \"../utils/crypto\";\nimport { getRoomIdFromUrl, extractRoomIdFromLink } from \"../utils/url\";\nimport SingleRoom from \"./SingleRoom\";\n\nconst roomIdFromUrl = getRoomIdFromUrl();\nconst userId = secureRandomId();\n\nconst SingleRoomEntrance: React.FC = () => {\n  const [roomId, setRoomId] = useState<string | null>(roomIdFromUrl);\n  const [linkText, setLinkText] = useState(\"\");\n\n  const onCreateNew = () => {\n    setRoomId(secureRandomId());\n  };\n\n  const onEnter = () => {\n    setRoomId(extractRoomIdFromLink(linkText));\n  };\n\n  if (roomId) {\n    return <SingleRoom roomId={roomId} userId={userId} />;\n  }\n\n  return (\n    <div className=\"SingleRoomEntrance-init\">\n      <button type=\"button\" onClick={onCreateNew}>\n        Create a new room\n      </button>\n      OR\n      <input\n        value={linkText}\n        onChange={(e) => setLinkText(e.target.value)}\n        placeholder=\"Enter room link...\"\n      />\n      <button\n        type=\"button\"\n        onClick={onEnter}\n        disabled={!extractRoomIdFromLink(linkText)}\n      >\n        Enter room\n      </button>\n    </div>\n  );\n};\n\nexport default SingleRoomEntrance;\n","import React from \"react\";\n\nimport ErrorFallback from \"./ErrorFallback\";\nimport SingleRoomEntrance from \"./SingleRoomEntrance\";\nimport \"./App.css\";\n\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  render() {\n    const { children } = this.props;\n    const { hasError } = this.state;\n    if (hasError) return <ErrorFallback />;\n    return children;\n  }\n}\n\nconst App: React.FC = () => (\n  <div className=\"App\">\n    <ErrorBoundary>\n      <SingleRoomEntrance />\n    </ErrorBoundary>\n  </div>\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}